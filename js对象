<!--
 * @Author: your name
 * @Date: 2022-03-02 08:31:15
 * @LastEditTime: 2022-03-02 08:31:15
 * @LastEditors: Please set LastEditors
 * @Description: 对象
 * @FilePath: \hNote\js对象.md
-->
### 对象、this指向
##### 对象
    javascript对象是一个变量，变量的值是一个容器。
    比如：
    
```
var person = {
  firstName: "Bill",
  lastName : "Gates",
  id       : 678,
  fullName : function() {
    return this.firstName + " " + this.lastName;
  }
};
```
对象容器中的键值对被称为属性，属性可以是方法。
访问对象的属性可以是如下几种：

```
person.firstName;
person['firstName'];
person.fullName();
name = person.fullName()//实例化对象
```
还可以通过new关键字创建对象：

```
var x = new String();        // 把 x 声明为 String 对象
var y = new Number();        // 把 y 声明为 Number 对象
var z = new Boolean();       //	把 z 声明为 Boolean 对象
```
##### this指向
在绝大多数情况下this的指向由函数的调用决定。
全局上下文：无论是否在严格模式下，在全局执行环境中（在任何函数体外部）this 都指向全局对象。在浏览器中, window 对象同时也是全局对象。

```
// 在浏览器中, window 对象同时也是全局对象：
console.log(this === window); // true

a = 37;
console.log(window.a); // 37

this.b = "MDN";
console.log(window.b)  // "MDN"
console.log(b)         // "MDN"
```

函数上下文：在函数内部，this的值取决于函数被调用的方式。因为下面的代码不在严格模式下，且 this 的值不是由该调用设置的，所以 this 的值默认指向全局对象。

```
function f1(){
  return this;
}
//在浏览器中：
f1() === window;   //在浏览器中，全局对象是window

//在Node中：
f1() === globalThis;
```
然而，在严格模式下，如果进入执行环境时没有设置 this 的值，this 会保持为 undefined，如下：

```
function f2(){
  "use strict"; // 这里是严格模式
  return this;
}

f2() === undefined; // true
```
==如果要想把 this 的值从一个环境传到另一个，就要用 call 或者apply 方法。==
类上下文：在类的构造函数中，this 是一个常规对象。类中所有非静态的方法都会被添加到 this 的原型中：

```
class Example {
  constructor() {
    const proto = Object.getPrototypeOf(this);
    console.log(Object.getOwnPropertyNames(proto));
  }
  first(){}
  second(){}
  static third(){}
}

new Example(); // ['constructor', 'first', 'second']
```
